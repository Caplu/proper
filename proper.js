//     (c) 2012 Victor Saiz, Michael Aufreiter
//     Proper is freely distributable under the MIT license.
//     For all details and documentation:
//     http://github.com/substance/proper

// Goals:
//
// * Annotations (strong, em, code, link) are exclusive. No text can be both
//   emphasized and strong.
// * The output is plain.
// * Cross-browser compatibility: Support the most recent versions of Chrome,
//   Safari, Firefox and Internet Explorer. Proper should behave the same on
//   all these platforms (if possible).

(function(){
  
  // Proper
  // ------

  this.Proper = function(options){

    var range
      , annotationList = []
      , options = options || {};

    var defaults = { 
      lineWrapping: true,
      lineNumbers: false
    };

    var overrides = {
      lineWrapping: true,
      onCursorActivity: function(cm){
        // Set the selection range
        var from = cm.getCursor(true);
        var to = cm.getCursor(false);
        var str = cm.getSelection();
        range = {'from':from, 'to':to, 'str': str};
      }
    };

    // Merge options
    _.extend(defaults, options);
    _.extend(options, overrides);

    // Init codeMirror
    var cm = CodeMirror.fromTextArea($(options.el)[0], options);

    // Resets the cursor selection to the actual range
    function restetCursor(range){
      // Reselect trimmed range and string value
      cm.setSelection(range.from, range.to);
    }

    // Unselects left or right blank characters
    function trim(sel){
      var first = sel.str.charCodeAt(0);
      var last = sel.str.charCodeAt(sel.str.length-1);
      // Check if first character is blank and adjusts the annotation range if it is
      if(first === 32){
        sel.from.ch = sel.from.ch + 1;
      }

      // Check if last character is blank and adjusts the annotation range if it is
      if(last === 32){
        sel.to.ch = sel.to.ch - 1;
      }

      sel.str = cm.getRange(sel.from, sel.to);
      return sel;
    }

    // Turns position line objects into a single value representing the offset from character 0
    function toOffset(pos){
      var offset = 0;
      if(pos.line > 0){
        var i = 0;
        for(; i < pos.line; i++ ){
          offset += cm.lineInfo(i).text.length + 1;//count the newline character as 1?
        }
      }
      return pos.ch + offset;
    }
    
    // Returns the current selection
    function selection(){
      range = trim(range);
      var start = toOffset(range.from);
      var end = toOffset(range.to);
      return {'start': start, 'end': end};
    }

    // Adds annotation (uses the current selection)
    function annotate(note){
      note.pos = selection();
      //autogenerated id based on the type and the ofsset position string
      note.id = note.type + '/' + note.pos.start + '' + note.pos.end;
      restetCursor(range);
      annotationList.push(note);
    }

    // Returns list of annotations
    var annotations = function(){
      return annotationList;
    };

    //API
    return {
      selection: selection,
      annotate: annotate,
      annotations: annotations
    };
  };
   

})();